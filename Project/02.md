# Elektronica (I)

Voor het project wensen we één Arduino te gebruiken, zonder bijkomende externe stroom. Daarbij hebben we 64 LEDs en 64 drukknoppen nodig die onafhankelijk van elkaar moeten kunnen oplichten resp.&nbsp;ingedrukt worden. Het theoretisch eenvoudigst zou zijn om elke drukknop te verbinden met een unieke ingang van de Arduino, en elke LED met een unieke uitgang. De Arduino heeft uiteraard geen 128 poortjes en dus moeten we wat creatiever zijn. We kijken al eens naar de noodzakelijke elektronica, waarbij we de Arduino nog beschouwen als een abstracte _black box_ met een aantal pinnen die output kunnen geven of input kunnen opvragen. Het enige wat we moeten weten, zijn de volgende axioma's.
 * Een pin in `OUTPUT`-modus kan in de software een signaal geven van 5 V (`HIGH`) of 0 V (`LOW`).
 * Een pin in `INPUT`-modus waar 5 V op staat, registreert `HIGH`.<br />
  Een pin in `INPUT`-modus waar 0 V op staat, registreert `LOW`.<br />
  Een "floating" pin in `INPUT`-modus, die niet in een gesloten circuit zit, kan zowel `HIGH` of `LOW` registreren.
 * Een pin in `INPUT_PULLUP`-modus waar 5 V op staat, registreert `HIGH`.<br />
  Een pin in `INPUT_PULLUP`-modus waar 0 V op staat, registreert `LOW`.<br />
  Een "floating" pin in `INPUT_PULLUP`-modus, die niet in een gesloten circuit zit, registreert `HIGH` (!!).

[Lees meer hierover.](https://www.arduino.cc/en/Tutorial/Foundations/DigitalPins)

Disclaimer: mijn enige ervaring in dit gebied is louter theoretische middelbareschoolkennis. Het verslag hieronder staat dan ook vol met bedenkingen die voor de elektronicageek volstrekt triviaal zijn, maar de leek misschien wel een hoop kopzorgen en frustratie kunnen besparen.

## Pull-up vs. pull-down resistoren

We beginnen heel simpel: hoe kunnen we de Arduino verbinden met een drukknop en nagaan of die ingedrukt is of niet? Het ligt voor de hand om de drukknop enerzijds te verbinden met een vaste spanningsbron van 5 V en anderzijds met een inputpin van de Arduino. Is de knop ingedrukt, dan sluit het circuit en detecteert de inputpin het signaal `HIGH`. Is anderzijds de knop niet ingedrukt, dan is de inputpin in floating toestand en dan detecteert de pin (in `INPUT`-modus) ruis, bestaande uit variabel `HIGH` en `LOW`. Niet bruikbaar dus!

We moeten gebruikmaken van de pin in `INPUT_PULLUP`-modus, die we dan via de drukknop moeten verbinden met een vaste "spanningsbron" van 0 V (de grond). Is de knop ingedrukt, dan detecteert de pin het signaal `LOW`. Is de knop niet ingedrukt, dan detecteert de pin het signaal `HIGH`. Nogal contra-intuïtief, maar zo kunnen we wel de toestand van de knop eenduidig bepalen uit het opgepikte signaal met een minimum aan elektronica.

Vanwaar de benaming _"pull up"_? Dat verwijst naar het gebruik van een weerstand ingebouwd in de pin die softwarematig wordt geactiveerd. Los van de Arduino zijn er twee manieren om een weerstand te integreren in een drukknopcircuit om de onvoorspelbaarheid van floating waarden tegen te gaan: _pulling down_ en _pulling up_.

De _pull down_ staat hieronder links. Daar wordt de spanning in de inputpin naar de grond toe getrokken zodat die ondubbelzinnig de waarde 0 V aangeeft. De drukknop sluiten doet spanning in input oplopen tot 5 V, en doet een stroom naar de grond ontstaan (vandaar de weerstand). De _pull up_ hieronder rechts doet het omgekeerde: die trekt default de spanning in de inputpin op, zodat die ondubbelzinnig de waarde 5 V aangeeft, tot de drukknop wordt gesloten en de stroom naar de grond kan afvloeien. [Klik hier voor een simulatie in de applet Falstad.](http://falstad.com/circuit/circuitjs.html?ctz=CQAgjCAMB0l3BWcMBMcUHYMGZIA4UA2ATmIxAUgpABZsAoAJXBpvBTxbbDBSn5pUkVEdARMQ2PNw6Tp4XvyqDqIqGPoBzcMT65uuydkJQttbHshs6e46YDOXdpzCsQaTlQgAXAE4BXAFN6AHl3FV5OFAjFCEhQ2jwvWRokhT44+gB3cOSolQ9TXx1LAz5Cr3hsp0KwQwrquvL8XPcW+OKpGU4uts9kOHpHGz7zUv4fAOCc3sKRhpz5ltSqBcTV5bTI0wAPNuJ3O2wwVewDtmiQAAd-ABtbgB17ABMAeyyAO3o91gOUOwQdUO53C1zuj3s-iu33Y5GIXkIVGI2FooNe-m8MP+EHh4QOyNRlwAll89tgMDjlFYQASLmx0ZifhSaco8PiUXSQCT6EA)

![pulldownpullup](../assets/images/05pdpu.jpg "pull down vs. pull up")

Ook in de Arduino wordt de waarde van een inputpin met `INPUT_PULLUP`-modus standaard opgetrokken tot `HIGH`. We moeten het circuit dan zodanig ontwerpen dat de knop activeren ervoor zorgt dat in de pin de waarde `LOW` wordt geregistreerd. Nee, `INPUT_PULLDOWN`-modus bestaat niet &#9786;

## Matrix van drukknoppen (I)

Dit wetende implementeren we al eens een enkele knop, heel rechttoe-rechtaan, in een Tinkercadsimulatie.

![1button](../assets/images/project/1button.png "één knop")

De `GND`-pin (ground) kunnen we interpreteren als een vaste output `LOW`, pin 3 is de inputpin (met pull up), en we gebruiken de ingebouwde LED om aan te geven of de knop is ingedrukt of niet. De code spreekt voor zich.

```c++
void setup() {
  pinMode(3, INPUT_PULLUP);
  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  if (digitalRead(3) == LOW) {
    digitalWrite(LED_BUILTIN, HIGH); //LED on
  } else {
    digitalWrite(LED_BUILTIN, LOW);  //LED off
  }
}
```

We kunnen eventueel ook een andere pin van de Arduino dan de ground gebruiken. Hier stellen we pin 2 in als een pin met vaste output `LOW`, met hetzelfde resultaat. Deze methode zal nuttig blijken verderop, omdat we de outputwaarde van de pin puur softwarematig kunnen wijzigen.

![1button](../assets/images/project/1button2.png "één knop")

```c++
void setup() {
  pinMode(2, OUTPUT);
  digitalWrite(2, LOW);
  pinMode(3, INPUT_PULLUP);
  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  if (digitalRead(3) == LOW) {
    digitalWrite(LED_BUILTIN, HIGH); //LED on
  } else {
    digitalWrite(LED_BUILTIN, LOW);  //LED off
  }
}
```

Passen we in dit voorbeeld de output aan naar `HIGH` en testen we of de inputpin `HIGH` detecteert, dan merken we op dat de LED non-stop brandt, met of zonder pull up. Vandaar de nood aan de `INPUT_PULLUP`-modus die zonder extra elektronica bruikbare resultaten geeft.

Helaas ligt het probleem van deze methode voor de hand: voor meerdere knoppen kunnen we weliswaar een gemeenschappelijke outputpin gebruiken, maar als elke drukknop met een unieke inputpin dient te worden verbonden, dan hebben we in totaal 64 (+1) pinnen nodig voor een 8×8-bord.

## Matrix van drukknoppen (II)

Een eerste vereenvoudiging zal het probleem van een kwadratisch aantal pinnen (_n_<sup>2</sup> voor een _n_×_n_-spelbord) reduceren naar een lineair aantal (2_n_). Hiervoor verbinden we alle knoppen in een rij van het rooster met eenzelfde outputpin en alle knoppen in een kolom met eenzelfde inputpin, zoals op de figuur.

![9buttons](../assets/images/project/9buttons.png "negen knoppen")

De Arduino zal herhaaldelijk elk van de outputpinnen eens op `LOW` zetten, voor elk van de inputpinnen controleren of die een `LOW` signaal opvangt, en de outputpin dan weer terugzetten op `HIGH`. Uit de informatie welke inputpin `LOW` geeft bij welke outputpin valt zo te achterhalen welke drukknop precies wordt ingedrukt. Onderstaand programma geeft het principe weer. Dit keer laten we niet gewoon een LEDje oplichten maar schrijft de Arduino naar de console uit welke drukknop gedetecteerd wordt.

```c++
//row pins, top to bottom
const int ROWS[3] = {7, 6, 5};
//column pins, left to right
const int COLS[3] = {2, 3, 4};

void setup() {
  //set pin modes
  for (int n = 0; n < 3; ++n) {
    pinMode(ROWS[n], OUTPUT);
    digitalWrite(ROWS[n], HIGH);
    pinMode(COLS[n], INPUT_PULLUP);
  }
  //allow for output on the console
  Serial.begin(9600);
}

void loop() {
  //loop over rows
  for (int R = 0; R < 3; ++R) {
    digitalWrite(ROWS[R], LOW);
    //loop over columns
    for (int C = 0; C < 3; ++C) {
      //check button in row R, column C
      if (digitalRead(COLS[C]) == LOW) {
        Serial.print("Button ");
        Serial.print(3*R + C + 1);
        Serial.println(" detected!");
      }
    }
    digitalWrite(ROWS[R], HIGH);
  }
  //don't overkill the console
  delay(100);
}
```

Helaas leidt het voorgestelde procédé nog steeds tot 16 pinnen voor het vooropgestelde spelbord. Een merkbare efficiëntiewinst, waarmee we nog steeds zo goed als alle pinnen van de Arduino hebben opgebruikt voor enkel drukknoppen. We willen graag de mogelijkheid openlaten om later uitbreidingsmodules toe te voegen (zoals een elektronische dobbelsteen?) en zoeken dan ook verder naar een elegantere methode.

## Matrix van drukknoppen (III)

Een oplossing die onze voorkeur geniet, maakt gebruikt van een [_shift register_](https://en.wikipedia.org/wiki/Shift_register) of schuifregister. Grof gezegd is zo'n schuifregister in staat om één serieel inputsignaal te scheiden naar acht afzonderlijke signalen (type _serial-in parallel-out_) of omgekeerd (type _parallel-in serial-out_). Door meerdere schuifregisters aan elkaar te schakelen, zou dat aantal kunnen worden opgetrokken, maar voor onze doeleinden is één zo'n elementje precies gepast. Op deze manier volstaan drie pinnen om acht (en in principe arbitrair veel) rijen van drukknoppen aan te drijven: één voor de data, één voor de "klok", en één om de output effectief uit te schrijven.

![shiftregister0](https://lastminuteengineers.com/wp-content/uploads/arduino/74HC595-Shift-Register-Working.gif)

In Tinkercad zit de 74HC595 ingebouwd, het meestgebruikte model. Een kort overzicht van het gebruik ervan, zoals zelf [hier](https://lastminuteengineers.com/74hc595-shift-register-arduino-tutorial/) geleerd:

![shiftregister1](../assets/images/project/shiftregister.png "schuifregister")

 - **power** vereist een constante `HIGH` en wordt dus best aangesloten op de 5V-uitgang van de Arduino;
 - **ground** vereist een constante `LOW` en wordt dus best aangesloten op de grond van de Arduino;
 - **serial input** ontvangt de seriële input;
 - **shift register clock** stuurt op elk `HIGH` signaal de bits één positie door;
 - **output register clock** or **latch** activeert op een `HIGH` signaal de acht uitgangen met de huidige bits;
 - **clear register clock** reset op een `LOW` signaal alle huidige bits op `LOW`;
 - **output enable** blokkeert de uitgangen zolang deze `HIGH` ontvangt;
 - **output 1** t.e.m. **output 8** zijn de effectieve uitgangen;
 - **output 8\*** geeft een kopie van output 8 die niet gelatcht hoeft te worden en dus toelaat door te koppelen aan een volgend schuifregister.

We hebben in Tinkercad een klein project gebouwd om de mogelijkheden te demonstreren. Om nog wat nieuwe componenten te leren, gebruiken we dit keer een _7 segment LED display_ als visuele feedback. Deze sketch functioneert als een heel rudimentaire counter die seconden telt. De Arduino stuurt via outputpin 3 telkens een byte door die bepaalt welke segmenten van de display oplichten. Ondertussen drijven pinnen 4 en 5 de hulpmechanismen van het schuifregister aan. Merk op dat zeven bits volstaan voor het LED display en dat we de eerste bit negeren.

![shiftregister2](../assets/images/project/shiftregister2.png "schuifregister")

De functie `shiftOut()` stuurt telkens de data bit per bit door en activeert ondertussen ook telkens de klok van het schuifregister. Eenmaal volledig doorgestuurd wordt de latch geactiveerd en lichten de juiste LEDs op.

```c++
//shift register serial input pin
int dataPin = 3;
//shift register latch pin
int latchPin = 4;
//shift register clock pin
int clockPin = 5;

//digit bytes on LED display
byte ledDigits[10] = {
  0b10000001, //digit 0
  0b11001111, //digit 1
  0b10010010, //digit 2
  0b10000110, //digit 3
  0b11001100, //digit 4
  0b10100100, //digit 5
  0b10100000, //digit 6
  0b10001111, //digit 7
  0b10000000, //digit 8
  0b10000100  //digit 9
};

void setup() {
  pinMode(dataPin, OUTPUT);
  pinMode(latchPin, OUTPUT);
  pinMode(clockPin, OUTPUT);
}

void loop() {
  for (int i = 0; i < 10; ++i) {
    digitalWrite(latchPin, LOW);
    shiftOut(dataPin, clockPin, LSBFIRST, ledDigits[i]);
    digitalWrite(latchPin, HIGH);
    delay(1000);
  }
}
```

> ⚠️ We leerden achteraf dat we beter zeven afzonderlijke weerstanden hadden gebruikt voor de LED-segmenten in plaats van één gemeenschappelijke. [Lees hier waarom.](https://electronics.stackexchange.com/questions/22291/why-exactly-cant-a-single-resistor-be-used-for-many-parallel-leds)

Voor onze drukknoppenmatrix hoeven we dus geen acht pinnen met output voor de acht rijen te gebruiken, maar kunnen we met drie pinnen één schuifregister bedienen dat dezelfde klus klaart.

Deze 74HC595 is van type _serial-in parallel-out_ (SIPO). Als we daarnaast een schuifregister van type _parallel-in serial-out_ (PISO) zoals de 74HC165 ter beschikking hebben, dan kunnen we op analoge manier de data van de acht kolommen verzamelen en in één byte doorgeven naar een inputpin van de Arduino. Op die manier kunnen we met slechts zes pinnen alle 64 knoppen op het bord monitoren. <!-- TODO: kunnen we deze met dezelfde klokpin verbinden?-->
